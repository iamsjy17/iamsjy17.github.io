---
layout: post
title: "[알고리즘_기초] 알고리즘에 필요한 수학 정리"
date: 2019-05-09 19:00:00
author: 송튜디오
categories: 알고리즘_기초
tags: 수학 알고리즘 에라토스테네스의체 에라토스테네스 순열 소수
---

알고리즘 문제 풀이에 많이 등장하는 수학 문제들과 유용하게 사용할 수 있는 몇 가지 수학들입니다.

### 소수

소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다.

- 모든 자연수는 소수의 곱으로 나타낼 수 있다는 규칙이 있다.
- 84 = 2^2 _ 3^1 _ 5^0 _ 7^1 _ 11^0 _ 13^0 _ 17^0 \* ...
  - 위 수식에서 많은 소수의 지수 부분이 0이다.
- 가분성(divisibility)
  - 어떤 수 x로 y를 나눌 수 있으려면 x를 소수의 곱으로 분할하였을 때,
  - 나열되는 모든 소수는 y를 소수의 곱으로 분할하였을 때 나열되는 모든 소수들의 부분집합이다.
  - x = 2^j0 _ 3^j1 _ 5^j2 _ 7^j3 _ 11^j4 \* .. 이고,
  - y = 2^k0 _ 3^k1 _ 5^k2 _ 7^k3 _ 11^k4 \* .. 일 때,
  - x가 y로 나누어 떨어지면 ji <= ki를 만족한다.
  - 즉, x/y를 만족하려면 모든 i에 대해 ji <= ki를 만족해야 한다.

#### x와 y의 최대공약수(greatest common divisor)

gcd(x, y) = 2^min(j0, k0) _ 3^min(j1, k1) _ 5^min(j2, k2) \* ...

#### x와 y의 최소공배수(least common multiple)

lcm(x, y) = 2^max(j0, k0) _ 3^max(j1, k1) _ 5^max(j2, k2) \* ...

#### 소수 판별

어떤 수 n이 소수인지 여부를 판별하는 가장 단순한 방법은 2에서 n-1까지 루프를 돌면서 나누어지는 경우가 있는지 확인하는 것이다.

```js
function primeNaive(n) {
  if (n < 2) {
    return false;
  }
  for (var i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
```

#### 에라토스테네스의 접근

루프를 n이 아닌 n의 제곱근까지만 돌고도 소수를 판별할 수 있다.

```js
function primeNaive2(n) {
  if (n < 2) {
    return false;
  }
  var sqrt = Math.sqrt(n);
  for (var i = 2; i <= sqrt; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
```

- 제곱근까지만 검사해도 소수를 판별할 수 있는 이유는, n을 나누는 모든 숫자 a는 그에 대한 보수 b가 반드시 존재하기 때문이다.
- b : (a\*b=n)
- 만일 a > sqrt(n) 이라면 b < sqrt(n) 이다.(sqrt(n)^2 = n)
- 따라서 n이 소수인지 판별하기 위해 a까지 검사할 필요는 없다.
- 주어진 자연수 N이 소수이기 위한 필요충분 조건은 N이 N의 제곱근보다 크지 않은 어떤 소수로도 나눠지지 않는다.
- 수가 수를 나누면 몫이 발생하게 되는데 몫과 나누는 수, `둘 중 하나`는 반드시 `N의 제곱근 이하`이기 때문이다.

#### 에라토스테네스의 체

- 에라토스테네스의 체는 소수 목록을 만드는 굉장히 효율적인 방법이다.
- 이 알고리즘은 소수가 아닌 수들은 반드시 다른 소수로 나누어진다는 사실에 기반해서 동작한다.
- 1 ~ n까지의 리스트를 만든다.
- 그리고 첫 번째, 2로 나누어지는 모든 수를 리스트에서 없앤다.
- 그 후에 2, 3, 5, 7.. 등의 소수로 나뉘는 모든 수들을 리스트에서 삭제한다.

```js
function sieveOfEratosthenes(max) {
  var flags = [].fill.call({ length: max + 1 }, true, 2);
  var prime = 2;

  while (prime <= Math.sqrt(max)) {
    crossOff(flags, prime);
    prime = getNextPrime(flags, prime);
  }
}

// 배수 제거 함수
function crossOff(flags, prime) {
  /*
    prime의 배수들을 제거해나간다. k < prime인 k에 대한 k * prime은 이전 루프에서 이미 제거되었을 것이므로
    prime * prime부터 시작한다.
    */
  for (var i = prime * prime; i < flags.length; i += prime) {
    flags[i] = false;
  }
}

// 다음 소수를 찾는 함수
function getNextPrime(flags, prime) {
  var next = prime + 1;
  while (next < flags.length && !flags[next]) {
    next++;
  }
  return next;
}
```

### 확률

- AnB의 확률
  - A에 속해있으면서도 B에 속해 있을 확률
  - P(AnB) = P(B|A)P(A)
  - 예) 1~10까지의 수 중 5이하 이면서, 짝수일 확률
  - 5이하일 확률 = 50%, 5이하 숫자 중 짝수일 확률 = 40%
  - 1/2 \* 2/5 = 1/5
  - 베이즈 정리
    - P(AnB) = P(B|A)P(A) = P(A|B)P(B)
    - P(A|B) = P(B|A)P(A) / P(B)
- AuB의 확률
  - P(AuB) = P(A)+P(B)-P(AnB)

#### 독립성과 상호 배타성

- 독립성
  - A와 B가 독립사건(한 사건의 발생과 다른 사건의 발생 사이에 아무런 관계가 없는 경우)이라면, A가 B에 아무런 영향을 끼치지 않는다.
  - P(B|A) = P(B)
  - P(AnB) = P(A)P(B)
- 상호 배타성(mutual exclusivity)
  - A와 B가 상호 배타적(한 사건이 일어난 경우 다른 사건은 발생할 수 없는 경우)라면,
  - P(AnB) = 0
  - P(AuB) = P(A) + P(B)
- 독립성과 상호 배타성은 완전히 다른 개념이다.
  - 상호 배타성은 한 사건이 발생하면 다른 사건이 발생할 수 없다는 관계가 존재한다.
  - 독립성은 한 사건의 발생 여부가 다른 사건에 아무런 영향을 미치지 않아야 한다.
  - 따라서 두 사건의 확률이 0보다 큰 경우 두 조건을 동시에 만족시킬 수 없다.
  - 두 사건 중 하나의 확률이 0이라면, 두 사건은 독립적이면서 상호 배타적이다.

### 1부터 n가지의 합

- 1 + 2 + 3 + .... + n 은 짝은 값과 큰 값을 하나의 쌍으로 만들어서 생각해 볼 수 있다.
  - n이 짝수라면 1과 n, 2와 n-1의 순으로 짝을 짓는다.
    - 합이 n+1이 되는 쌍이 n/2개 나온다.
    - => (n+1)\*n/2
  - n이 홀수라면 0과 n, 1과 n-1의 순으로 짝을 짓는다.
    - 합이 n이 되는 쌍이 (n+1)/2개 나온다.
    - => n\*(n+1)/2
- 1 + 2 + 3 + .... + n = n\*(n+1)/2

### 2의 승수의 합

- 2^0 + 2^1 + 2^2 + ... 2^n

  - 값을 2진수로 생각해 보면 간단하다.
  - 0부터 n까지의 2의 승수의 합 = 2^(n+1) - 1

    | 승수        | 2진수 | 10진수 |
    | ----------- | :---: | -----: |
    | 0           | 00001 |      2 |
    | 1           | 00010 |      4 |
    | 2           | 00100 |      8 |
    | 3           | 01000 |     16 |
    | 4           | 10000 |     32 |
    | 합 : 2^5 -1 | 11111 |     64 |

### 로그의 밑

log_2를 log_10으로 바꿀 수 있는 방법은 로그의 법칙을 통해 증명할 수 있다.

- 로그의 법칙
  - log_b(k) log_x(k)가 있을 때,
  - log_b(k) = c
  - b^c = k
  - log_x(b^c)
  - c \* log_x(b) = log_x(k)
  - c = log_x(k) / log_x(b)
  - 따라서,
  - log_2(p)를 log_10으로 변환 방법은 아래와 같다.
  - log_10(p) = log_2(p) / log_2(10)

### 순열

중복되는 문자가 없을 때, 길이가 n인 문자열을 재배열하는 방법은 n!개이다.

- 첫 번째 위치에 놓을 수 있는 문자 n개
- 두 번째 위치에 놓을 수 있는 문자 n-1개 ...
- n! = n*(n-1) * (n-2) \* (n-2)

총 n개의 문자로 길이가 k인 문자열을 만들때는 다음과 같다.

- n!/(n-k)! = n _ (n-1) _ (n-2) .... \* (n-k+1)

### 조합

n개의 문자의 집합이 있을 때, 이 중에서 k개의 문자를 선택하여 새로운 집합을 만들 때 만들 수 있는 부분집합의 수 구하기.

- n개의 원소 중 크기가 k인 부분집합의 개수(순서에 상관없이)
- nCk
- 길이가 k인 부분 문자열의 개수 n!/(n-k)!
- 길이가 k인 부분집합을 재배치하여 만들 수 있는 문자열의 개수는 k! 이므로,
- 각 부분 문자열 리스트에는 각각의 부분집합이 k!번 반복 사용되었다.
- n!/k!(n-k)!

## 참고

- https://ko.wikipedia.org/wiki/소수_(수론)
- 코딩인터뷰 완전정복
